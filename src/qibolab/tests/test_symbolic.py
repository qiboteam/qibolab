"""Tests ``symbolic.py``."""

from qibolab.symbolic import (
    SymbolicExpression,
    floatSymbolicExpression,
    intSymbolicExpression,
)


def test_symbolic_init():
    intSymbolicExpression.clear_instances()

    # def __init__(self, expression = 0, symbol:str = ''):
    se = intSymbolicExpression(0, "se")  # Initialisation with int expression and symbol
    assert repr(se) == "se: 0 = 0"

    se0 = intSymbolicExpression(0)  # Initialisation only with int expression.
    assert repr(se0) == "_sym_int0: 0 = 0"  # A unique symbol _sym_int is generated by the class

    se1 = intSymbolicExpression(1)
    assert repr(se1) == "_sym_int1: 1 = 1"

    se2 = intSymbolicExpression("8 // 4")  # Initialisation with a string expression (when evaluated must return an int)
    assert repr(se2) == "_sym_int2: 8 // 4 = 2"

    se3 = intSymbolicExpression(
        "(se + 3)"
    )  # Initialisation with a string expression using other intSymbolicExpressions
    assert repr(se3) == "_sym_int3: (se + 3) = 3"

    se4 = intSymbolicExpression(se3)  # Initialisation with another intSymbolicExpression
    assert (
        repr(se4) == "_sym_int4: (se + 3) = 3"
    )  # doing so copies the expression of the intSymbolicExpression argument

    se5 = intSymbolicExpression(
        se3 * 3, "se5"
    )  # Initialisation with an expression that returns a intSymbolicExpression
    assert repr(se5) == "se5: ((se + 3) * 3) = 9"

    assert repr(SymbolicExpression.instances["se"]) == "se: 0 = 0"
    assert repr(SymbolicExpression.instances["_sym_int0"]) == "_sym_int0: 0 = 0"
    assert repr(SymbolicExpression.instances["_sym_int1"]) == "_sym_int1: 1 = 1"
    assert repr(SymbolicExpression.instances["_sym_int2"]) == "_sym_int2: 8 // 4 = 2"
    assert repr(SymbolicExpression.instances["_sym_int3"]) == "_sym_int3: (se + 3) = 3"
    assert repr(SymbolicExpression.instances["_sym_int4"]) == "_sym_int4: (se + 3) = 3"
    assert repr(SymbolicExpression.instances["_sym_int5"]) == "_sym_int5: ((se + 3) * 3) = 9"
    assert repr(SymbolicExpression.instances["se5"]) == "se5: ((se + 3) * 3) = 9"

    se0 = intSymbolicExpression(
        10, "_sym_int0"
    )  # Defining a new instance with an existing symbol overwrites the old definition
    assert repr(se0) == "_sym_int0: 10 = 10"
    assert repr(SymbolicExpression.instances["_sym_int0"]) == "_sym_int0: 10 = 10"


def test_symbolic_symbol():
    intSymbolicExpression.clear_instances()
    # @property
    # def symbol(self) -> str:
    t0 = intSymbolicExpression(0, "t0")
    assert t0.symbol == "t0"

    # @symbol.setter
    # def symbol(self, symbol:str):
    t0.symbol = "modified_t0"
    assert t0.symbol == "modified_t0"

    assert repr(intSymbolicExpression.instances) == "{'modified_t0': modified_t0: 0 = 0}"

    # def __getitem__(self, symbol):
    t1 = intSymbolicExpression(1)["t1"]  # Defining a new instance and renaming it to 't1' afterwards
    assert t1.symbol == "t1"

    # This abuse of the __getitem__ method, in conjunction with class operators allows this:
    t2 = (t1 + 1)["t2"]  # operations between a intSymbolicExpression and another intSymbolicExpression or int
    # return a intSymbolicExpression
    assert t2.symbol == "t2"
    assert repr(t2) == "t2: (t1 + 1) = 2"

    assert repr(SymbolicExpression.instances["modified_t0"]) == "modified_t0: 0 = 0"
    assert repr(SymbolicExpression.instances["t1"]) == "t1: 1 = 1"
    assert repr(SymbolicExpression.instances["t2"]) == "t2: (t1 + 1) = 2"


def test_symbolic_expression():
    intSymbolicExpression.clear_instances()
    t0 = intSymbolicExpression(0, "t0")
    t1 = (t0 + 5)["t1"]
    # @property
    # def expression(self):
    assert t1.expression == "(t0 + 5)"
    # @expression.setter
    # def expression(self, expression): # (self, expression:str|int|intSymbolicExpression):
    t1.expression = 7  # setting intSymbolicExpression expression using an int
    assert t1.expression == "7"
    assert t1.value == 7

    t1.expression = "3 + 3"  # setting intSymbolicExpression expression using a str expression
    assert t1.expression == "3 + 3"
    assert t1.value == 6

    t1.expression = t0 + 1  # setting intSymbolicExpression expression using another intSymbolicExpression
    assert t1.expression == "(t0 + 1)"

    assert (
        repr(intSymbolicExpression.instances)
        == "{'t0': t0: 0 = 0, 't1': t1: (t0 + 1) = 1, '_sym_int1': _sym_int1: (t0 + 1) = 1}"
    )
    # The evaluation of t0 + 1 as a intSymbolicExpression has created a new record in intSymbolicExpression.instances '_sym_int1'


def test_symbolic_value():
    intSymbolicExpression.clear_instances()

    # @property
    # def value(self) -> int:
    t0 = intSymbolicExpression(77, "t0")
    assert t0.value == 77

    # @value.setter
    # def value(self, value:int):
    t0.value = 99  # one can set a intSymbolicExpression.value (only with an int)
    assert t0.value == 99
    assert t0.expression == "99"  # the expression is updated accordingly


def test_symbolic_is_constant():
    intSymbolicExpression.clear_instances()

    # @property
    # def is_constant(self) -> bool:

    t0 = intSymbolicExpression(0, "t0")
    t1 = (2 * (t0 + 7))["t1"]

    assert t0.is_constant
    assert not t1.is_constant

    t1.value = 15

    assert t1.is_constant
    assert repr(intSymbolicExpression.instances) == "{'t0': t0: 0 = 0, 't1': t1: 15 = 15}"


def test_symbolic_circular_reference_error():
    intSymbolicExpression.clear_instances()

    t0 = intSymbolicExpression(0, "t0")
    t1 = intSymbolicExpression(t0 + 1, "t1")
    CircularReferenceError_raised = False
    ValueError_raised = False

    try:
        t0 = intSymbolicExpression(t1 + 1, "t0")
    except intSymbolicExpression.CircularReferenceError:
        CircularReferenceError_raised = True
    except ValueError:
        ValueError_raised = True
    except:
        assert False

    assert CircularReferenceError_raised
    assert not ValueError_raised
    assert repr(t1) == "t1: (t0 + 1) = CircularReferenceError"

    assert repr(SymbolicExpression.instances["t0"]) == "t0: (t1 + 1) = CircularReferenceError"
    assert repr(SymbolicExpression.instances["t1"]) == "t1: (t0 + 1) = CircularReferenceError"
    assert repr(SymbolicExpression.instances["_sym_int1"]) == "_sym_int1: (t1 + 1) = CircularReferenceError"


def test_symbolic_evaluate():
    pass


def test_symbolic_type_conversions():
    assert int(intSymbolicExpression(7)) == 7
    assert float(intSymbolicExpression(7)) == 7.0
    assert str(intSymbolicExpression(7)) == "7"


def test_symbolic_operators():
    intSymbolicExpression.clear_instances()

    assert intSymbolicExpression(1) > intSymbolicExpression(0)
    assert intSymbolicExpression(0) < intSymbolicExpression(1)
    assert intSymbolicExpression(0) <= intSymbolicExpression(0)
    assert intSymbolicExpression(0) <= intSymbolicExpression(1)
    assert intSymbolicExpression(0) >= intSymbolicExpression(0)
    assert intSymbolicExpression(1) >= intSymbolicExpression(0)
    assert intSymbolicExpression(7) == intSymbolicExpression(7)
    assert intSymbolicExpression(5) != intSymbolicExpression(3)
    t0 = intSymbolicExpression(5)
    t1 = t0 + 2
    t2 = intSymbolicExpression(7)
    assert (t1 == t2) and (t1.expression != t2.expression) and (t1.value == t2.value)

    intSymbolicExpression.clear_instances()

    t2 = intSymbolicExpression(2)
    t5 = intSymbolicExpression(5)

    se_operation = t2 + 1
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 3
    se_operation = t2 + t5
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 7
    se_operation = 1 + t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 3

    se_operation = t5 - 3
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 2
    se_operation = t5 - t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 3
    se_operation = 0 - t5
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == -5

    se_operation = t2 * 2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 4
    se_operation = t2 * t5
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 10
    se_operation = 3 * t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 6

    se_operation = t5 // 2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 2
    se_operation = t5 // t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 2
    se_operation = 5 // t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 2

    se_operation = t5 % 2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 1
    se_operation = t5 % t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 1
    se_operation = 5 % t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == 1

    se_operation = -t2
    assert isinstance(se_operation, intSymbolicExpression) and se_operation.value == -2

    intSymbolicExpression.clear_instances()

    t2 = intSymbolicExpression(2)
    t5 = intSymbolicExpression(5)
    t10 = intSymbolicExpression(10)

    t = intSymbolicExpression(2)
    t += 1
    assert isinstance(t, intSymbolicExpression) and t.value == 3

    t = intSymbolicExpression(5)
    t -= 1
    assert isinstance(t, intSymbolicExpression) and t.value == 4

    t = intSymbolicExpression(10)
    t *= 2
    assert isinstance(t, intSymbolicExpression) and t.value == 20

    t = intSymbolicExpression(5)
    t //= 2
    assert isinstance(t, intSymbolicExpression) and t.value == 2

    t = intSymbolicExpression(5)
    t %= 2
    assert isinstance(t, intSymbolicExpression) and t.value == 1


def test_symbolic_mixed_type_operators():
    SymbolicExpression.clear_instances()

    se1 = intSymbolicExpression(7, "se1")
    se2 = (se1 + 5)["se2"]
    se2 = se1 + 5
    se3 = (3 * (se1 - 1) + (se1 + se2))["se3"]
    se4 = se2 - se3

    se4 += 2

    assert repr(SymbolicExpression.instances["se1"]) == "se1: 7 = 7"
    assert repr(SymbolicExpression.instances["_sym_int1"]) == "_sym_int1: (se1 + 5) = 12"
    assert repr(SymbolicExpression.instances["se3"]) == "se3: ((3 * (se1 - 1)) + (se1 + (se1 + 5))) = 37"
    assert repr(SymbolicExpression.instances["_sym_int6"]) == "_sym_int6: (((se1 + 5) - se3) + 2) = -23"

    SymbolicExpression.clear_instances()

    se1 = floatSymbolicExpression(7 / 2, "se1")
    se2 = (se1 + 5)["se2"]
    se2 = se1 + 5
    se3 = (3 * (se1 - 1) + (se1 + se2))["se3"]
    se4 = se2 - se3

    assert repr(SymbolicExpression.instances["se1"]) == "se1: 3.5 = 3.5"
    assert repr(SymbolicExpression.instances["_sym_float1"]) == "_sym_float1: (se1 + 5) = 8.5"
    assert repr(SymbolicExpression.instances["se3"]) == "se3: ((3 * (se1 - 1)) + (se1 + (se1 + 5))) = 19.5"
    assert repr(SymbolicExpression.instances["_sym_float6"]) == "_sym_float6: ((se1 + 5) - se3) = -11.0"
